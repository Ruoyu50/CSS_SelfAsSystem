阶段 0 — 准备 & 版本控制（必须）

目的：初始化项目，确保能运行 HTML。
	•	新建文件夹、复制文件结构、初始化 git（可选）。
	•	把上面给的 index.html、style.css、data/mockData.json、data/mockData.csv、空 js 文件放好。
验收：在浏览器打开 index.html，能看到页面框架与空画布。

⸻

阶段 1 — 最简单的六边形可视化（渲染基础）

目标：实现 Hexagon 的渲染（静态）并渲染一组 mock 数据。
要做的事：
	•	在 hexagon.js 实现 Hexagon + Triangle 基本类（不含物理）。
	•	main.js 在 setup() 加载 mockData.json，为每条记录创建一个 Hexagon，并在 draw() 中调用 hex.draw()。
验收：
	•	打开页面能看到若干六边形（由 6 个三角形组成），颜色由 colorMapper 决定。
	•	验证：六边形绘制正确，顺序正确（triangle indices 对应属性）。

⸻

阶段 2 — 运动与旋转（线速度 + 角速度）

目标：让每个 Hexagon 有 vx,vy,omega 并在画布中移动与自转（AM 顺时针、PM 逆时针）。
要做的事：
	•	Hexagon 增加 vx, vy, omega、update(dt)、computeWorldVertices()。
	•	在 main.draw() 每帧调用 hex.update(dt)，然后 hex.draw()。
	•	AM 初始化 omega 为负（顺时针），PM 初始化 omega 为正（逆时针）。
验收：
	•	六边形在画布中移动并旋转，AM/PM 的角速度方向相反。
	•	可以用 console.log 输出一个 hex 的 omega 验证方向。

⸻

	1.	phase2.0
	•	阶段二的基础功能：六边形移动 + 旋转
	•	AM/PM 方向不同
	2.	phase2.1
	•	基于 phase2.0 的改进分支
	•	调试输出、性能优化、速度控制
	•	不会覆盖阶段三的碰撞逻辑
	3.	main / phase2.1
	•	你可以把 phase2.1 合并或直接作为主线分支
	•	阶段三可以从这里继续开发
	4.	分支管理策略
	•	保留每个阶段的分支方便回溯
	•	2.1 改进完成后可选择合并到 main 或保留分支名
	•	阶段三直接在 phase2.1 上开发，不影响 2.0 历史
	
	
阶段 3 — 边界反弹 + 顶点检测（记录顶点碰边）

目标：实现顶点画布边缘检测并记录碰撞（不做复杂冲量，仅反转速度分量即可作为第一版）。
要做的事：
	•	physics.checkBoundaryCollisions(hex, w, h)：遍历 hex world 顶点，检测是否越界。
	•	当顶点越界并且相对速度沿边法线指向外侧时：
	•	简单响应：反转 vx 或 vy（初版），并做小位置修正。
	•	Logger.logVertexBoundary({hexId, triangleIndex, vertexIndex, edge, vertexPos, timestamp})
验收：
	•	顶点碰到边时，页面 console 输出/ UI 统计增加 vertexBoundary 数量。
	•	Logger.vertexBoundaryCollisions 能导出 JSON/CSV（测试导出）。

⸻

	•	phase3.2 — 速度衰减/摩擦优化
	•	在 Hexagon.update() 里加入摩擦系数（例如 0.99），防止速度无限增长，使运动更自然。
	•	验收：长时间运行后六边形不会失控，速度逐渐平稳。
	•	phase3.3 — Logger 统计 API
	•	在 logger.js 里增加统计方法，例如 countCollisionsByHex(hexId)。
	•	验收：能在控制台查询某个 hex 的碰撞次数，Logger 支持简单分析。
	•	phase3.4 — 导出功能（JSON/CSV 基础版）
	•	在 Logger 增加 exportCSV()，和已有 exportJSON() 并行。
	•	验收：可将日志导出成字符串 CSV，确认内容结构正确。
	•	phase3.5 — 可视化辅助调试（可选）
	•	在 main.js 的 draw() 里给发生碰撞的顶点画个小红点，方便直观验证。
	•	验收：碰撞时画布上能闪现标记，和 Logger 输出一致。

phase3.6
必须任务
	1.	Logger 扩展字段
	•	保留现有 vertexBoundary 信息。
	•	添加可选字段，如：
	•	三角形索引（triangleIndex）
	•	六边形中心坐标（hex x, y）
	•	可选择的 velocity 信息（vx, vy, omega）
	•	保证导出 JSON/CSV 时这些字段能正确输出。
	2.	Physics/Hexagon 接口完善
	•	Hexagon.computeWorldVertices() 保持正确，确保 phase4 扫描顶点时可直接调用。
	•	Physics.checkBoundaryCollisions() 保持稳定，不修改现有反弹逻辑，但可增加小注释说明各参数意义。
	•	确保 update()、buildTriangles()、draw() 接口明确，不会破坏数据。
	3.	数据稳定性检查
	•	在 draw() 或单元测试中确认：
	•	hexagon 顶点位置和 vx/vy/omega 正确记录。
	•	Logger 数据完整且可导出。

⸻

可选优化 / 扩展
	1.	Logger 调试增强
	•	提供函数如 Logger.getLastNEvents(n)，方便快速调试。
	•	可选将 Logger 暂挂到 window（调试用），但最终注释掉。
	2.	UI / 可视化辅助
	•	继续在 draw() 中显示红点，但不修改现有动画逻辑。
	•	可选显示每个 hex 的 id 或碰撞次数。
	3.	性能优化（轻量）
	•	保证 Logger 数据不无限增长（recentCollisions 已经实现 N 条限制）。
	•	确保 update() 的摩擦衰减和 dt 帧率独立逻辑无误。

⸻

验收标准
	1.	Hexagon 的顶点、速度、角速度数据完整、稳定。
	2.	Logger 可导出 JSON/CSV，字段齐全。
	3.	更新 draw() 时红点显示正确。
	4.	确认 Hexagon/Physics 接口可直接复用到 phase4。
	5.	不改变现有 phase3.5 的动画或碰撞逻辑。



阶段 4 — AM × PM 之间的 vertex–edge 检测（判定）

目标：实现 AM-PM 的点到线段接触检测（不含完整冲量求解，先做检测并记录）。
要做的事：
	•	physics.vertexEdgeContactTest(vertex, p, q)：计算最近点 C，距离 d，法线 n。
	•	在 main.update() 对每个 AM hex 与每个 PM hex 扫描 hexA.vertices × hexB.edges，当 d ≤ tolerance 且相对速度沿 n < 0 则记录：
	•	Logger.logInteraction({type:'vertex_edge', vertexOwner, edgeOwner, triangleIndex, contactPoint, normal, timestamp})
	•	先把碰撞响应留为：交换 vx,vy（简单近似），后续替换更真实冲量模型。
验收：
	•	AM 与 PM 的接触被检测到并记录（检查 Logger 数组）。
	•	临时高亮被击中 edge 或 vertex（便于可视化调试）。

	phase4.0 — 基础 vertex–edge 检测
		•	新增 Physics.vertexEdgeContactTest()
		•	验证点到线段距离、法线计算正确。
	phase4.1 — Logger 接入
		•	在循环中记录 vertex–edge 接触。
		•	验收：Logger.interactions 有数据，包含 vertexOwner、edgeOwner 等字段。
	phase4.2 — 可视化高亮（调试）
		•	在 draw() 中绘制被击中顶点/边的标记。
		•	验收：高亮点/线显示正确，动画不受影响。
	phase4.3 — 优化与稳定性
		•	增加 tolerance 参数，优化检测逻辑（可选 broad-phase）。
		•	限制 Logger 数据长度，避免无限增长。
		•	验收：性能稳定，数据完整。

⸻


阶段 5 — 弹性冲量响应（精确版）

目标：把碰撞响应替换为物理上正确的弹性冲量（线-角耦合）。
要做的事：
	•	在 physics.js 实现 computeImpulseAndApply(hexA, rA, hexB, rB, n, v_rel)，用公式计算 J 并更新 vx, vy, omega（参见前面的公式）。
	•	在 boundary 碰撞中把边界视为静止刚体（m=inf）。
	•	做小的穿透修正（position correction）。
验收：
	•	碰撞后两物体的 vx, vy, omega 更新合理（观察日志）。
	•	系统总能保持能量守恒（e≈1 的情况下），不会无故升高/降低速度（观察 long-run）。

⸻

阶段 6 — 完善导入/导出与 UI

目标：实现文件导入（CSV/JSON）、导出交互日志（CSV/JSON）、并完善控件。
要做的事：
	•	controls.js 绑文件上传：读取 file → DataImporter.parseCSV/parseJSON → DataImporter.importData(records) → 清空 hexagons 与 logger，并创建 hexagons。
	•	导出：Logger.exportJSON()、Logger.exportCSV()（包含 vertexBoundary & interactions）。
	•	UI 显示计数器与导入成功消息。
验收：
	•	能上传示例 CSV/JSON，页面用新数据渲染 hexagons。
	•	能导出交互数据为文件并打开查看。

⸻

阶段 7 — 性能与优化（可选但建议）

目标：当 hex 数量较大时保持流畅。
要做的事：
	•	引入 spatial hash / quadtree 在 vertex-edge 检测前做 broad-phase（只检测邻近 hex 对）。
	•	减少 GC（避免每帧 new 向量，复用对象）。
	•	调整渲染（只 draw 需要显示的元素或降低帧率）。
验收：
	•	100+ hex 在普通浏览器仍能保持可交互帧率（≥30 fps）或合理降帧。

⸻

阶段 8 — 可视化/分析页面（可选）

目标：增加统计图、热力图、事件回放等。
	•	利用导出的日志做碰撞次数分布、被击中 triangle 热力图等。